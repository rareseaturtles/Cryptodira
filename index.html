<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Twitter Card Metadata -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cryptodira - Save Sea Turtles">
    <meta name="twitter:description" content="Join Cryptodira on Solana to support sea turtle conservation efforts!">
    <meta name="twitter:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta name="twitter:site" content="@rareseaturtles">
    <meta name="twitter:creator" content="@rareseaturtles">
    <!-- Open Graph Metadata -->
    <meta property="og:title" content="Cryptodira - Save Sea Turtles">
    <meta property="og:description" content="Cryptodira: A Solana token dedicated to sea turtle conservation. Get involved today!">
    <meta property="og:url" content="https://cryptodira.netlify.app/">
    <meta property="og:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta property="og:type" content="website">
    <!-- SEO Meta Tags -->
    <meta name="description" content="Cryptodira is a Solana-based token supporting sea turtle conservation with community-driven initiatives.">
    <meta name="keywords" content="Cryptodira, sea turtle conservation, Solana token, environmental protection, crypto for good">
    <meta name="author" content="Cryptodira Team">
    <!-- Favicon -->
    <link rel="icon" href="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" type="image/jpeg">
    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.91.1/lib/index.iife.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #e0f7fa, #b2dfdb);
            color: #1a3c34;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
        }
        header {
            text-align: center;
            padding: 30px 0;
            background: rgba(178, 223, 219, 0.3);
            width: 100%;
        }
        header h1 {
            font-size: 52px;
            color: #0d4536;
            margin: 10px 0;
            text-shadow: 2px 2px 6px rgba(13, 69, 54, 0.3);
            font-family: 'Roboto', sans-serif;
        }
        header p {
            font-size: 20px;
            color: #0d4536;
            margin: 0;
        }
        .logo {
            width: 150px;
            height: auto;
            border-radius: 15px;
            border: 5px solid #0d4536;
            margin: 20px auto;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
        }
        .logo:hover {
            transform: scale(1.1);
        }
        .content {
            background: #ffffff;
            padding: 30px;
            margin: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            width: 90%;
            border: 4px solid #26a69a;
            text-align: center;
        }
        .content h2, .content h3 {
            color: #0d4536;
            margin-bottom: 20px;
            font-family: 'Roboto', sans-serif;
        }
        .content p {
            font-size: 18px;
            line-height: 1.8;
            color: #37474f;
            margin-bottom: 20px;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
        }
        .button {
            padding: 15px 30px;
            font-size: 18px;
            color: #fff;
            background: linear-gradient(135deg, #26a69a, #00695c);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 180px;
        }
        .button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #00695c, #003d33);
        }
        #disconnect-btn {
            background: linear-gradient(135deg, #ef5350, #b71c1c);
            display: none;
        }
        #disconnect-btn:hover {
            background: linear-gradient(135deg, #b71c1c, #7f0000);
        }
        #status, #gameStatus {
            margin-top: 20px;
            font-size: 18px;
            color: #0d4536;
            font-weight: bold;
        }
        .roadmap {
            margin: 25px 0;
            padding: 25px;
            background: rgba(178, 223, 219, 0.5);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .roadmap ul {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        .roadmap li {
            margin: 15px 0;
            font-size: 18px;
            color: #0d4536;
            position: relative;
            padding-left: 30px;
        }
        .roadmap li::before {
            content: "✔";
            color: #26a69a;
            position: absolute;
            left: 0;
            font-weight: bold;
        }
        .roadmap li.in-progress::before {
            content: "▶";
            color: #ffca28;
        }
        .roadmap li.future::before {
            content: "○";
            color: #b0bec5;
        }
        .featured-nft {
            margin: 25px 0;
            padding: 20px;
            background: rgba(178, 223, 219, 0.3);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .featured-nft img {
            max-width: 200px;
            height: auto;
            border: 3px solid #26a69a;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        footer {
            background: #0d4536;
            color: #fff;
            text-align: center;
            padding: 15px 0;
            width: 100%;
            margin-top: auto;
        }
        #token-info {
            font-size: 18px;
            color: #0d4536;
        }
        #gameCanvas {
            border: 4px solid #26a69a;
            background: linear-gradient(180deg, #4dd0e1, #00acc1);
            max-width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }
        #startBtn, #resetBtn {
            padding: 15px 30px;
            font-size: 18px;
            color: #fff;
            background: linear-gradient(135deg, #26a69a, #00695c);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            min-width: 180px;
            margin: 20px auto;
        }
        #startBtn:hover, #resetBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #00695c, #003d33);
        }
        @media (max-width: 600px) {
            header h1 { font-size: 36px; }
            .content { padding: 20px; margin: 15px; width: 95%; }
            .button, #startBtn, #resetBtn { padding: 12px 25px; font-size: 16px; min-width: 140px; }
            .buttons { gap: 15px; }
            .logo { width: 120px; }
            #gameCanvas { width: 100%; height: 400px; }
            .featured-nft img { max-width: 150px; }
        }
    </style>
</head>
<body>
    <header>
        <img class="logo" src="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" alt="Cryptodira Turtle Logo">
        <h1>Cryptodira</h1>
        <p>Supporting Sea Turtle Conservation on Solana</p>
    </header>

    <div class="content">
        <h2>Welcome to Cryptodira ($DIRA)</h2>
        <p>Cryptodira is a Solana-based token dedicated to protecting sea turtles and promoting environmental conservation through community efforts.</p>
        
        <div class="buttons">
            <button class="button" id="connect-btn" onclick="connectWallet()">Connect Wallet</button>
            <button class="button" id="disconnect-btn" onclick="disconnectWallet()">Disconnect</button>
        </div>
        <div id="status"></div>

        <h3>Tokenomics</h3>
        <div id="token-info">
            <p>Loading token data...</p>
            <button class="button" onclick="updateTokenInfo()">Refresh</button>
        </div>

        <h3>Featured NFT</h3>
        <div class="featured-nft">
            <p>Check out one of our exclusive Rare Sea Turtles NFTs! <a href="https://opensea.io/collection/rare-sea-turtles" target="_blank" class="button" style="display: inline-block; padding: 5px 10px; font-size: 14px;">Explore Collection</a></p>
            <img src="/assets/Turtle.jpg" alt="Featured Turtle NFT">
        </div>

        <h3>Roadmap to Grow MC and Conservation Funding</h3>
        <div class="roadmap">
            <ul>
                <li class="in-progress"><strong>Stage 1 (Complete):</strong> Achieved 15k MC, established 120k $DIRA conservation fund. <a href="https://opensea.io/collection/rare-sea-turtles" target="_blank" class="button" style="display: inline-block; padding: 5px 10px; font-size: 14px;">Check Our NFTs!</a></li>
                <li class="in-progress"><strong>Stage 2 (Complete):</strong> Reached 30k MC, grew conservation fund to 300k $DIRA. <a href="https://opensea.io/collection/rare-sea-turtles" target="_blank" class="button" style="display: inline-block; padding: 5px 10px; font-size: 14px;">Explore the Collection!</a></li>
                <li class="in-progress"><strong>Stage 3 (In Progress):</strong> Target 35k MC, increase conservation fund to 325k $DIRA by September 2025.</li>
                <li class="future"><strong>Stage 4:</strong> Aim for 40k MC, grow conservation fund to 350k $DIRA by October 2025.</li>
                <li class="future"><strong>Stage 5:</strong> Reach 50k MC, boost conservation fund to 400k $DIRA by December 2025.</li>
            </ul>
        </div>

        <h3>Join the Community</h3>
        <div class="buttons">
            <a href="https://app.meteora.ag/pools/9H67psNKre9dMAscpsYkEPGmYFw4MjeqV5Rmott2mDmd?internal=true" class="button" target="_blank">Swap on Meteora</a>
            <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" class="button" target="_blank">Birdeye Chart</a>
            <a href="https://x.com/rareseaturtles" class="button" target="_blank">Follow on X</a>
            <a href="https://t.me/+FsJKNuEXxRRmZGRh" class="button" target="_blank">Join Telegram</a>
            <a href="https://solscan.io/account/293Py67fg8fNYMt1USR6Vb5pkG1Wxp5ehaSAPQvBYsJy" class="button" target="_blank">CDCF Wallet</a>
        </div>
    </div>

    <div class="content">
        <h2>Ocean Cleanup Challenge</h2>
        <p>Tap to clear 50 trash items in 30 seconds to save 5 sea turtles! Turtles are saved when no trash overlaps them. Earn points for each cleared item!</p>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameStatus">Turtles Saved: <span id="turtlesSaved">0/5</span> | Score: <span id="score">0</span> | High Score: <span id="highScore">0</span> | Time: <span id="timeLeft">30</span>s</div>
        <button id="startBtn">Start Challenge!</button>
        <button id="resetBtn">Reset Game</button>
    </div>

    <footer>
        <p>© 2025 Cryptodira. Committed to Sea Turtle Conservation.</p>
    </footer>

    <script>
        // DOM elements
        const connectBtn = document.getElementById("connect-btn");
        const disconnectBtn = document.getElementById("disconnect-btn");
        const statusEl = document.getElementById("status");
        const tokenInfoEl = document.getElementById("token-info");
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameStatus = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const turtlesSavedEl = document.getElementById('turtlesSaved');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const timeLeftEl = document.getElementById('timeLeft');

        // Solana config
        const TOKEN_MINT_ADDRESS = new solanaWeb3.PublicKey("53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8");
        const RPC_ENDPOINT = "https://solana-mainnet.g.alchemy.com/v2/FhRe8GPzziOkp5qiOF5OO4erPzDYvoF_";
        const FALLBACK_RPC_ENDPOINT = "https://api.mainnet-beta.solana.com";
        const MIN_TOKEN_BALANCE = BigInt(5000000);
        let publicKey = null;
        let isTokenHolder = false;
        let walletProvider = null;
        let walletName = "Unknown";

        // Birdeye API key
        const BIRDEYE_API_KEY = "0d4d8f6a8444446cb233b2f2e933d6db";
        const TOTAL_TOKEN_SUPPLY = 4880000; // 4.88M tokens

        // Load images
        const turtleImage = new Image();
        turtleImage.src = '/assets/turtle.png'; // Reverted to original game turtle
        const trashImage = new Image();
        trashImage.src = '/assets/trash.png';
        const trash2Image = new Image();
        trash2Image.src = '/assets/trash2.png';
        const trash3Image = new Image();
        trash3Image.src = '/assets/trash3.png';

        // Fetch token price, liquidity, market cap, and holder count
        async function updateTokenInfo() {
            try {
                const birdeyeResponse = await fetch("https://public-api.birdeye.so/defi/price?address=53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8&check_liquidity=100&include_liquidity=true", {
                    headers: {
                        "X-API-KEY": BIRDEYE_API_KEY,
                        "x-chain": "solana",
                        "accept": "application/json"
                    }
                });
                if (!birdeyeResponse.ok) throw new Error(`Birdeye HTTP ${birdeyeResponse.status}`);
                const birdeyeData = await birdeyeResponse.json();
                const price = birdeyeData.data?.value?.toFixed(6) || "N/A";
                const liquidity = birdeyeData.data?.liquidity?.toFixed(2) || "N/A";
                const marketCap = price !== "N/A" ? (birdeyeData.data.value * TOTAL_TOKEN_SUPPLY).toFixed(2) : "N/A";

                const connection = new solanaWeb3.Connection("https://api.mainnet-beta.solana.com", "confirmed");
                const mintAddress = new solanaWeb3.PublicKey("53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8");
                const tokenProgramId = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

                let holderCount = 180;
                try {
                    const accounts = await connection.getProgramAccounts(tokenProgramId, {
                        filters: [
                            { dataSize: 165 },
                            { memcmp: { offset: 0, bytes: mintAddress.toBase58() } }
                        ],
                        commitment: "confirmed"
                    });
                    const uniqueHolders = new Set(accounts.map(acc => {
                        const accountInfo = solanaWeb3.BorshAccount.from(acc.account.data);
                        return accountInfo.owner.toString();
                    })).size;
                    holderCount = uniqueHolders > 0 ? uniqueHolders : 180;
                } catch (rpcError) {
                    console.warn("RPC call failed, defaulting to 180 holders:", rpcError.message);
                    holderCount = 180;
                }

                tokenInfoEl.innerHTML = `
                    <p><strong>Price:</strong> ${price !== "N/A" ? "$" + price : price}</p>
                    <p><strong>Liquidity:</strong> ${liquidity !== "N/A" ? "$" + liquidity : liquidity}</p>
                    <p><strong>Market Cap:</strong> ${marketCap !== "N/A" ? "$" + marketCap : marketCap}</p>
                    <p><strong>Holders:</strong> ${holderCount}</p>
                    <p><strong>Mission:</strong> Fund conservation through community participation.</p>
                    <p><strong>Track:</strong> <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" target="_blank">Birdeye</a></p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            } catch (error) {
                tokenInfoEl.innerHTML = `
                    <p>Error fetching token data: ${error.message}. Check network or retry later.</p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            }
        }

        updateTokenInfo();

        function getConnection() {
            try {
                return new solanaWeb3.Connection(RPC_ENDPOINT, "confirmed");
            } catch (error) {
                console.warn("Primary RPC failed, switching to fallback:", error);
                return new solanaWeb3.Connection(FALLBACK_RPC_ENDPOINT, "confirmed");
            }
        }

        async function connectWallet() {
            walletProvider = null;
            publicKey = null;
            walletName = "Unknown";

            if (window.solana && window.solana.isPhantom) {
                walletProvider = window.solana;
                walletName = "Phantom";
            } else if (window.backpack && window.backpack.isBackpack) {
                walletProvider = window.backpack;
                walletName = "Backpack";
            } else if (window.jup) {
                walletProvider = window.jup;
                walletName = "Jupiter Mobile";
            } else if (window.solflare && window.solflare.isSolflare) {
                walletProvider = window.solflare;
                walletName = "Solflare";
            } else {
                statusEl.textContent = 'No supported wallet detected. Install <a href="https://phantom.app/" target="_blank" style="color: #0d4536;">Phantom</a>.';
                return;
            }

            try {
                const response = await walletProvider.connect();
                publicKey = walletProvider.publicKey ? walletProvider.publicKey.toString() : response.publicKey.toString();
                statusEl.textContent = `Connected: ${publicKey.slice(0, 6)}...${publicKey.slice(-4)} with ${walletName}`;
                connectBtn.style.display = "none";
                disconnectBtn.style.display = "inline-block";
                await checkTokenOwnership();
            } catch (error) {
                statusEl.textContent = `Wallet connection failed: ${error.message}`;
            }
        }

        function disconnectWallet() {
            if (walletProvider && walletProvider.disconnect) {
                walletProvider.disconnect();
            }
            publicKey = null;
            walletProvider = null;
            isTokenHolder = false;
            statusEl.textContent = "Wallet disconnected";
            connectBtn.style.display = "block";
            disconnectBtn.style.display = "none";
        }

        async function checkTokenOwnership() {
            if (!publicKey) {
                statusEl.textContent = "No wallet connected.";
                return;
            }
            const connection = getConnection();
            try {
                const tokenAccounts = await connection.getTokenAccountsByOwner(
                    new solanaWeb3.PublicKey(publicKey),
                    { mint: TOKEN_MINT_ADDRESS }
                );
                let totalBalance = BigInt(0);
                for (const account of tokenAccounts.value) {
                    const balance = account.account.data.readBigUInt64LE(64);
                    totalBalance += balance;
                }
                isTokenHolder = totalBalance > MIN_TOKEN_BALANCE;
                if (isTokenHolder) {
                    statusEl.textContent = `Verified: You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA (500+ tokens)!`;
                } else {
                    statusEl.textContent = `You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA. Need 500+ for benefits.`;
                }
            } catch (error) {
                statusEl.textContent = "Error checking token: " + error.message;
            }
        }

        // Game Logic for Ocean Cleanup
        const canvasWidth = 800;
        const canvasHeight = 600;
        let turtlesSaved = 0;
        let score = 0;
        let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
        const totalTrash = 50;
        const totalTurtles = 5;
        let gameActive = false;
        let trashItems = [];
        let turtles = [];
        let animations = [];
        let timeLeft = 30;
        let timerInterval;

        class Item {
            constructor(type, x = null, y = null) {
                this.width = type === 'turtle' ? 150 : 50;
                this.height = this.width;
                if (type === 'turtle') {
                    const centerX = 400;
                    const centerY = 350;
                    const radius = 100;
                    const angle = (2 * Math.PI * turtles.length) / totalTurtles;
                    this.initialX = centerX + radius * Math.cos(angle) - this.width / 2;
                    this.initialY = centerY + radius * Math.sin(angle) - this.height / 2;
                    this.x = this.initialX;
                    this.y = this.initialY;
                    this.dx = Math.random() * 0.5 - 0.25;
                    this.dy = Math.random() * 0.5 - 0.25;
                } else if (x === null || y === null) {
                    this.x = Math.random() * (450 - this.width) + 175;
                    this.y = Math.random() * (450 - this.height) + 125;
                } else {
                    this.x = x + (Math.random() * 20 - 10);
                    this.y = y + (Math.random() * 20 - 10);
                }
                this.type = type;
                this.centerX = this.x + this.width / 2;
                this.centerY = this.y + this.height / 2;
                this.isSaved = type === 'turtle' ? false : undefined;
                this.image = type === 'turtle' ? turtleImage : [trashImage, trash2Image, trash3Image][Math.floor(Math.random() * 3)];
            }
            update() {
                if (this.type === 'turtle' && gameActive) {
                    this.x += this.dx;
                    this.y += this.dy;
                    if (this.x < 175 || this.x + this.width > 625) this.dx = -this.dx;
                    if (this.y < 125 || this.y + this.height > 575) this.dy = -this.dy;
                    this.centerX = this.x + this.width / 2;
                    this.centerY = this.y + this.height / 2;
                }
            }
            draw() {
                ctx.save();
                if (this.type === 'turtle') ctx.globalAlpha = this.isSaved ? 1 : 0.7;
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        class TapAnimation {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.opacity = 1;
                this.timer = 0;
            }
            update() { this.timer += 0.016; this.opacity -= 0.05; return this.opacity > 0; }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x + (this.type === 'turtle' ? 75 : 25), this.y + (this.type === 'turtle' ? 75 : 25), (this.type === 'turtle' ? 75 : 25) * (1 - this.timer), 0, Math.PI * 2);
                ctx.fillStyle = this.type === 'turtle' ? 'rgba(38, 166, 154, 0.5)' : 'rgba(102, 102, 102, 0.5)';
                ctx.fill();
                ctx.restore();
            }
        }

        function playSound(type) {
            const audio = new Audio(type === 'turtle' ? 'https://www.arweave.net/path/to/turtle.wav' : 'https://www.arweave.net/path/to/trash.wav');
            audio.play().catch(e => console.log("Audio error:", e));
        }

        function isOverlapping(newItem, existingItems) {
            for (const item of existingItems) {
                const dx = (newItem.x + newItem.width / 2) - (item.x + item.width / 2);
                const dy = (newItem.y + newItem.height / 2) - (item.y + item.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (newItem.width / 2 + item.width / 2)) return true;
            }
            return false;
        }

        function isTurtleOverlapped(turtle) {
            for (const trash of trashItems) {
                const dx = (turtle.x + turtle.width / 2) - (trash.x + trash.width / 2);
                const dy = (turtle.y + turtle.height / 2) - (trash.y + trash.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (turtle.width / 2 + trash.width / 2)) return true;
            }
            return false;
        }

        function updateSavedTurtles() {
            turtlesSaved = 0;
            turtles.forEach(turtle => {
                if (!isTurtleOverlapped(turtle)) {
                    turtle.isSaved = true;
                    turtlesSaved++;
                } else turtle.isSaved = false;
            });
            turtlesSavedEl.textContent = `${turtlesSaved}/${totalTurtles}`;
            if (turtlesSaved === totalTurtles) endGame(true);
        }

        function spawnCluster() {
            trashItems = [];
            turtles = [];
            for (let i = 0; i < totalTurtles; i++) turtles.push(new Item('turtle'));
            const gridCols = 10;
            const gridRows = Math.ceil((totalTrash - totalTurtles) / gridCols);
            const gridWidth = (450 - 50) / gridCols;
            const gridHeight = (450 - 50) / gridRows;
            let trashCount = 0;
            for (const turtle of turtles) {
                let trash, attempts = 0;
                do {
                    const offsetX = Math.random() * 50 - 25;
                    const offsetY = Math.random() * 50 - 25;
                    trash = new Item('trash', turtle.centerX + offsetX, turtle.centerY + offsetY);
                    attempts++;
                } while (isOverlapping(trash, trashItems) && attempts < 50);
                if (attempts < 50) { trashItems.push(trash); trashCount++; }
            }
            for (let row = 0; row < gridRows && trashCount < totalTrash; row++)
                for (let col = 0; col < gridCols && trashCount < totalTrash; col++) {
                    let trash, attempts = 0;
                    const baseX = 175 + col * gridWidth + gridWidth / 2;
                    const baseY = 125 + row * gridHeight + gridHeight / 2;
                    do { trash = new Item('trash', baseX, baseY); attempts++; }
                    while (isOverlapping(trash, trashItems) && attempts < 100);
                    if (attempts < 100) { trashItems.push(trash); trashCount++; }
                }
        }

        function handleTap(e, isTouch = false) {
            if (!gameActive) return;
            const rect = gameCanvas.getBoundingClientRect();
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            const clickX = clientX - rect.left;
            const clickY = clientY - rect.top;
            let closestItem = null;
            let minDistance = Infinity;
            trashItems.forEach((item, index) => {
                const dx = clickX - item.centerX;
                const dy = clickY - item.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 50 && distance < minDistance) { closestItem = { item, index }; minDistance = distance; }
            });
            if (closestItem) {
                const { item, index } = closestItem;
                animations.push(new TapAnimation(item.x, item.y, item.type));
                playSound(item.type);
                trashItems.splice(index, 1);
                score += 10;
                scoreEl.textContent = score;
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                    highScoreEl.textContent = highScore;
                }
                updateSavedTurtles();
            }
        }

        gameCanvas.addEventListener('click', handleTap);
        gameCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleTap(e, true); }, { passive: false });

        function gameLoop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Open Sans';
            ctx.textAlign = 'left';
            ctx.fillText(`Turtles Saved: ${turtlesSaved}/${totalTurtles}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 60);
            ctx.fillText(`High Score: ${highScore}`, 10, 90);
            ctx.fillText(`Time: ${Math.ceil(timeLeft)}s`, 10, 120);
            turtles.forEach(turtle => { turtle.update(); turtle.draw(); });
            trashItems.forEach(item => item.draw());
            animations = animations.filter(anim => anim.update());
            animations.forEach(anim => anim.draw());
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (!turtleImage.complete || !trashImage.complete || !trash2Image.complete || !trash3Image.complete) {
                console.log('Waiting for images to load...');
                setTimeout(startGame, 100);
                return;
            }
            turtlesSaved = 0;
            score = 0;
            trashItems = [];
            turtles = [];
            animations = [];
            timeLeft = 30;
            spawnCluster();
            turtlesSavedEl.textContent = `${turtlesSaved}/${totalTurtles}`;
            scoreEl.textContent = score;
            highScoreEl.textContent = highScore;
            timeLeftEl.textContent = Math.ceil(timeLeft);
            gameStatus.textContent = `Turtles Saved: ${turtlesSaved}/${totalTurtles} | Score: ${score} | High Score: ${highScore} | Time: ${Math.ceil(timeLeft)}s`;
            gameActive = true;
            startBtn.style.display = 'none';
            resetBtn.style.display = 'none';
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft -= 1;
                timeLeftEl.textContent = Math.max(0, Math.ceil(timeLeft));
                gameStatus.textContent = `Turtles Saved: ${turtlesSaved}/${totalTurtles} | Score: ${score} | High Score: ${highScore} | Time: ${Math.ceil(timeLeft)}s`;
                if (timeLeft <= 0) { clearInterval(timerInterval); endGame(false); }
            }, 1000);
            gameLoop();
        }

        function resetGame() {
            clearInterval(timerInterval);
            startGame();
        }

        function endGame(isVictory) {
            gameActive = false;
            clearInterval(timerInterval);
            ctx.fillStyle = isVictory ? 'rgba(38, 166, 154, 0.7)' : 'rgba(239, 83, 80, 0.7)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = '48px Roboto';
            ctx.fillText(isVictory ? 'Victory!' : 'Game Over!', canvasWidth / 2, canvasHeight / 2 - 70);
            ctx.font = '36px Open Sans';
            ctx.fillText(`Turtles Saved: ${turtlesSaved}/${totalTurtles}`, canvasWidth / 2, canvasHeight / 2);
            ctx.fillText(`Score: ${score}`, canvasWidth / 2, canvasHeight / 2 + 30);
            if (isVictory) {
                gameStatus.textContent = `Victory! Turtles Saved: ${turtlesSaved}/${totalTurtles} | Score: ${score} | High Score: ${highScore}`;
                for (let i = 0; i < 50; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * canvasWidth, Math.random() * canvasHeight, 5, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    ctx.fill();
                }
                playSound('turtle');
            } else {
                gameStatus.textContent = `Game Over! Turtles Saved: ${turtlesSaved}/${totalTurtles} | Score: ${score} | High Score: ${highScore}`;
            }
            startBtn.style.display = 'block';
            resetBtn.style.display = 'block';
        }

        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);
    </script>
</body>
</html>