<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Twitter Card Metadata -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cryptodira - Protecting Sea Turtles">
    <meta name="twitter:description" content="Join Cryptodira on Solana to support sea turtle conservation with NFT staking!">
    <meta name="twitter:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta name="twitter:site" content="@rareseaturtles">
    <meta name="twitter:creator" content="@rareseaturtles">
    <!-- Open Graph Metadata -->
    <meta property="og:title" content="Cryptodira - Protecting Sea Turtles">
    <meta property="og:description" content="Cryptodira: A Solana token for sea turtle conservation with NFT staking. Connect your wallet to join!">
    <meta property="og:url" content="https://cryptodira.netlify.app/">
    <meta property="og:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta property="og:type" content="website">
    <!-- Additional Metadata -->
    <title>Cryptodira - Protecting Sea Turtles</title>
    <meta name="description" content="Cryptodira is a Solana token dedicated to sea turtle conservation with NFT staking.">
    <!-- Favicon -->
    <link rel="icon" href="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" type="image/jpeg">
    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.91.1/lib/index.iife.min.js"></script>
    <!-- Google Fonts for Roboto -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #e0f7fa, #a5d6a7);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
        }
        header {
            text-align: center;
            padding: 20px 0;
            width: 100%;
        }
        header h1 {
            font-size: 48px;
            color: #1b5e20;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(46, 125, 50, 0.3);
            font-family: 'Trebuchet MS', sans-serif;
        }
        header p {
            font-size: 18px;
            color: #1b5e20;
            margin: 0;
        }
        .logo {
            width: 120px;
            height: auto;
            border-radius: 50%;
            border: 4px solid #2e7d32;
            margin: 20px auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            animation: float 2s infinite ease-in-out;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .logo:hover {
            transform: scale(1.05);
        }
        .content {
            background: #ffffff;
            padding: 25px;
            margin: 20px;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 90%;
            border: 3px solid #4caf50;
            text-align: center;
        }
        .content h2, .content h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }
        .content p {
            font-size: 16px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        .button {
            padding: 12px 25px;
            font-size: 16px;
            color: #fff;
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 150px;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #1b5e20, #103d15);
        }
        #disconnect-btn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            display: none;
        }
        #disconnect-btn:hover {
            background: linear-gradient(135deg, #b71c1c, #7f0000);
        }
        #status, #gameStatus {
            margin-top: 15px;
            font-size: 16px;
            color: #2e7d32;
            font-weight: bold;
        }
        .roadmap {
            margin: 20px 0;
            padding: 20px;
            background: rgba(232, 245, 233, 0.8);
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .roadmap ul {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        .roadmap li {
            margin: 10px 0;
            font-size: 16px;
            color: #1b5e20;
        }
        footer {
            background: #2e7d32;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            width: 100%;
            margin-top: auto;
        }
        #token-info {
            font-size: 16px;
            color: #1b5e20;
        }
        #gameCanvas {
            border: 3px solid #2e7d32;
            background: linear-gradient(180deg, #40c4ff, #0288d1);
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #startBtn, #resetBtn {
            padding: 12px 25px;
            font-size: 16px;
            color: #fff;
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            min-width: 150px;
            margin: 15px auto;
        }
        #startBtn:hover, #resetBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #1b5e20, #103d15);
        }
        @media (max-width: 600px) {
            header h1 { font-size: 32px; }
            .content { padding: 15px; margin: 15px; width: 95%; }
            .button, #startBtn, #resetBtn { padding: 10px 20px; font-size: 14px; min-width: 120px; }
            .buttons { flex-direction: column; align-items: center; gap: 10px; }
            .logo { width: 100px; }
            #gameCanvas { width: 100%; height: 400px; }
        }
    </style>
</head>
<body>
    <header>
        <img class="logo" src="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" alt="Cryptodira Sea Turtle Conservation Logo">
        <h1>Cryptodira</h1>
        <p>A Solana Token for Sea Turtle Conservation</p>
    </header>

    <div class="content">
        <h2>Welcome to Cryptodira ($DIRA)</h2>
        <p>Cryptodira is a Solana-based token dedicated to protecting sea turtles and supporting Earth conservation through community participation.</p>
        
        <div class="buttons">
            <button class="button" id="connect-btn" onclick="connectWallet()">Connect Wallet</button>
            <button class="button" id="disconnect-btn" onclick="disconnectWallet()">Disconnect</button>
        </div>
        <div id="status"></div>

        <h3>Tokenomics</h3>
        <div id="token-info">
            <p>Loading token data...</p>
            <button class="button" onclick="updateTokenInfo()">Refresh</button>
        </div>

        <h3>Roadmap to Grow MC and Conservation Funding</h3>
        <div class="roadmap">
            <ul>
                <li><strong>August 2025:</strong> Achieve 15k MC, increase conservation fund to 120k $DIRA.</li>
                <li><strong>September 2025:</strong> Reach 20k MC, grow conservation fund to 150k $DIRA.</li>
                <li><strong>October 2025:</strong> Hit 25k MC, expand conservation fund to 200k $DIRA.</li>
                <li><strong>November 2025:</strong> Target 30k MC, raise conservation fund to 250k $DIRA.</li>
                <li><strong>December 2025:</strong> Aim for 35k MC, boost conservation fund to 300k $DIRA.</li>
            </ul>
        </div>

        <h3>Join the Community</h3>
        <div class="buttons">
            <a href="https://app.meteora.ag/pools/9H67psNKre9dMAscpsYkEPGmYFw4MjeqV5Rmott2mDmd?internal=true" class="button" target="_blank">Swap on Meteora</a>
            <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" class="button" target="_blank">Birdeye Chart</a>
            <a href="https://x.com/rareseaturtles" class="button" target="_blank">Follow on X</a>
            <a href="https://t.me/+FsJKNuEXxRRmZGRh" class="button" target="_blank">Join Telegram</a>
            <a href="https://solscan.io/account/293Py67fg8fNYMt1USR6Vb5pkG1Wxp5ehaSAPQvBYsJy" class="button" target="_blank">CDCF Wallet</a>
        </div>
    </div>

    <div class="content">
        <h2>Ocean Cleanup</h2>
        <p>Tap to clear 150 trash items in 30 seconds to save 50 sea turtles! Turtles are saved when no trash overlaps them. Tap near the center of trash for accuracy (10 points per trash) to beat your high score!</p>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="gameStatus">Score: <span id="score">0</span> | Turtles Saved: <span id="turtlesSaved">0/50</span> | Time: <span id="timeLeft">30</span>s | High Score: <span id="highScore">0</span></div>
        <button id="startBtn">Start Cleaning!</button>
        <button id="resetBtn">Reset Game</button>
    </div>

    <footer>
        <p>Â© 2025 Cryptodira. Supporting Sea Turtle Conservation.</p>
    </footer>

    <script>
        // DOM elements
        const connectBtn = document.getElementById("connect-btn");
        const disconnectBtn = document.getElementById("disconnect-btn");
        const statusEl = document.getElementById("status");
        const tokenInfoEl = document.getElementById("token-info");
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameStatus = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const scoreEl = document.getElementById('score');
        const turtlesSavedEl = document.getElementById('turtlesSaved');
        const timeLeftEl = document.getElementById('timeLeft');
        const highScoreEl = document.getElementById('highScore');

        // Solana config
        const TOKEN_MINT_ADDRESS = new solanaWeb3.PublicKey("53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8");
        const RPC_ENDPOINT = "https://solana-mainnet.g.alchemy.com/v2/FhRe8GPzziOkp5qiOF5OO4erPzDYvoF_";
        const FALLBACK_RPC_ENDPOINT = "https://api.mainnet-beta.solana.com";
        const MIN_TOKEN_BALANCE = BigInt(5000000);
        let publicKey = null;
        let isTokenHolder = false;
        let walletProvider = null;
        let walletName = "Unknown";

        // Birdeye API key
        const BIRDEYE_API_KEY = "0d4d8f6a8444446cb233b2f2e933d6db";

        // Fetch token price and liquidity
        async function updateTokenInfo() {
            try {
                const response = await fetch("https://public-api.birdeye.so/defi/price?address=53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8&check_liquidity=100&include_liquidity=true", {
                    headers: {
                        "X-API-KEY": BIRDEYE_API_KEY,
                        "x-chain": "solana",
                        "accept": "application/json"
                    }
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Birdeye HTTP ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                tokenInfoEl.innerHTML = `
                    <p><strong>Price:</strong> $${data.data.value.toFixed(6)}</p>
                    <p><strong>Liquidity:</strong> $${data.data.liquidity.toFixed(2)}</p>
                    <p><strong>Mission:</strong> Fund conservation through community participation.</p>
                    <p><strong>Distribution:</strong> NFT stake to earn complete 100k Cryptodira in the conservation fund initial.</p>
                    <p><strong>Track:</strong> <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" target="_blank">Birdeye</a></p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            } catch (error) {
                tokenInfoEl.innerHTML = `
                    <p>Error fetching token data: ${error.message}</p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            }
        }

        updateTokenInfo();

        function getConnection() {
            try {
                return new solanaWeb3.Connection(RPC_ENDPOINT, "confirmed");
            } catch (error) {
                console.warn("Primary RPC failed, switching to fallback:", error);
                return new solanaWeb3.Connection(FALLBACK_RPC_ENDPOINT, "confirmed");
            }
        }

        async function connectWallet() {
            walletProvider = null;
            publicKey = null;
            walletName = "Unknown";

            if (window.solana && window.solana.isPhantom) {
                walletProvider = window.solana;
                walletName = "Phantom";
            } else if (window.backpack && window.backpack.isBackpack) {
                walletProvider = window.backpack;
                walletName = "Backpack";
            } else if (window.jup) {
                walletProvider = window.jup;
                walletName = "Jupiter Mobile";
            } else if (window.solflare && window.solflare.isSolflare) {
                walletProvider = window.solflare;
                walletName = "Solflare";
            } else {
                statusEl.textContent = 'No supported wallet detected. Install <a href="https://phantom.app/" target="_blank" style="color: #2e7d32;">Phantom</a>.';
                return;
            }

            try {
                const response = await walletProvider.connect();
                publicKey = walletProvider.publicKey
                    ? walletProvider.publicKey.toString()
                    : response.publicKey.toString();

                statusEl.textContent = `Connected: ${publicKey.slice(0, 6)}...${publicKey.slice(-4)} with ${walletName}`;
                connectBtn.style.display = "none";
                disconnectBtn.style.display = "inline-block";
                await checkTokenOwnership();
            } catch (error) {
                statusEl.textContent = `Wallet connection failed: ${error.message}`;
            }
        }

        function disconnectWallet() {
            if (walletProvider && walletProvider.disconnect) {
                walletProvider.disconnect();
            }
            publicKey = null;
            walletProvider = null;
            isTokenHolder = false;
            statusEl.textContent = "Wallet disconnected";
            connectBtn.style.display = "block";
            disconnectBtn.style.display = "none";
        }

        async function checkTokenOwnership() {
            if (!publicKey) {
                statusEl.textContent = "No wallet connected.";
                return;
            }
            const connection = getConnection();
            try {
                const tokenAccounts = await connection.getTokenAccountsByOwner(
                    new solanaWeb3.PublicKey(publicKey),
                    { mint: TOKEN_MINT_ADDRESS }
                );

                let totalBalance = BigInt(0);
                for (const account of tokenAccounts.value) {
                    const balance = account.account.data.readBigUInt64LE(64);
                    totalBalance += balance;
                }

                isTokenHolder = totalBalance > MIN_TOKEN_BALANCE;
                if (isTokenHolder) {
                    statusEl.textContent = `Verified: You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA (500+ tokens)!`;
                } else {
                    statusEl.textContent = `You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA. Need 500+ for monthly giveaways.`;
                }
            } catch (error) {
                statusEl.textContent = "Error checking token: " + error.message;
            }
        }

        // Game Logic for Ocean Cleanup
        const canvasWidth = 800;
        const canvasHeight = 400;
        let score = 0;
        let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
        let turtlesSaved = 0;
        const totalTrash = 150;
        const totalTurtles = 50;
        let gameActive = false;
        let trashItems = [];
        let turtles = [];
        let animations = [];
        let timeLeft = 30;
        let timerInterval;

        // Item (trash or turtle) object
        class Item {
            constructor(type) {
                this.width = 80;
                this.height = 80;
                this.x = Math.random() * (canvasWidth - this.width - 40) + 20;
                this.y = Math.random() * (canvasHeight - this.height - 40) + 20;
                this.type = type;
                this.centerX = this.x + this.width / 2;
                this.centerY = this.y + this.height / 2;
                this.isSaved = type === 'turtle' ? false : undefined; // Track if turtle is saved
            }
            draw() {
                ctx.fillStyle = this.type === 'turtle' ? (this.isSaved ? '#4caf50' : '#2e7d32') : '#666';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = '16px Roboto';
                ctx.textAlign = 'center';
                ctx.fillText(this.type === 'turtle' ? 'Turtle' : 'Trash', this.x + this.width / 2, this.y + this.height / 2 + 10);
            }
        }

        // Animation for tapped items
        class TapAnimation {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.opacity = 1;
                this.timer = 0;
            }
            update() {
                this.timer += 0.016;
                this.opacity -= 0.05;
                return this.opacity > 0;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x + 40, this.y + 40, 40 * (1 - this.timer), 0, Math.PI * 2);
                ctx.fillStyle = this.type === 'turtle' ? 'rgba(46, 125, 50, 0.5)' : 'rgba(102, 102, 102, 0.5)';
                ctx.fill();
                ctx.restore();
            }
        }

        // Sound effects
        function playSound(type) {
            const audio = new Audio(type === 'turtle' ? 'https://www.arweave.net/path/to/turtle.wav' : 'https://www.arweave.net/path/to/trash.wav'); // Replace with your URLs
            audio.play().catch(e => console.log("Audio error:", e));
        }

        // Check if two items overlap
        function isOverlapping(newItem, existingItems) {
            for (const item of existingItems) {
                const dx = (newItem.x + newItem.width / 2) - (item.x + item.width / 2);
                const dy = (newItem.y + newItem.height / 2) - (item.y + item.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (newItem.width / 2 + item.width / 2)) {
                    return true;
                }
            }
            return false;
        }

        // Check if a turtle is overlapped by any trash
        function isTurtleOverlapped(turtle) {
            for (const trash of trashItems) {
                const dx = (turtle.x + turtle.width / 2) - (trash.x + trash.width / 2);
                const dy = (turtle.y + turtle.height / 2) - (trash.y + trash.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (turtle.width / 2 + trash.width / 2)) {
                    return true;
                }
            }
            return false;
        }

        // Update saved turtles count
        function updateSavedTurtles() {
            turtlesSaved = 0;
            turtles.forEach(turtle => {
                if (!isTurtleOverlapped(turtle)) {
                    turtle.isSaved = true;
                    turtlesSaved++;
                } else {
                    turtle.isSaved = false;
                }
            });
            turtlesSavedEl.textContent = `${turtlesSaved}/${totalTurtles}`;
            if (turtlesSaved === turtles.length) {
                endGame(true); // Victory when all turtles are saved
            }
        }

        // Spawn turtles and trash
        function spawnCluster() {
            trashItems = [];
            turtles = [];

            // Spawn exactly 50 turtles, allowing turtle-turtle overlap
            for (let i = 0; i < totalTurtles; i++) {
                turtles.push(new Item('turtle'));
            }

            // Spawn exactly 150 trash items, allowing overlap with turtles
            for (let i = 0; i < totalTrash; i++) {
                trashItems.push(new Item('trash'));
            }
            console.log(`Spawned ${turtles.length} turtles and ${trashItems.length} trash items`);
        }

        // Handle clicks/taps for trash only
        function handleTap(e, isTouch = false) {
            if (!gameActive) return;
            const rect = gameCanvas.getBoundingClientRect();
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            const clickX = clientX - rect.left;
            const clickY = clientY - rect.top;

            let trashRemoved = false;
            trashItems.forEach((item, index) => {
                const dx = clickX - item.centerX;
                const dy = clickY - item.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 30) { // 30px radius for tap accuracy
                    animations.push(new TapAnimation(item.x, item.y, item.type));
                    playSound(item.type);
                    trashItems.splice(index, 1);
                    score += 10;
                    scoreEl.textContent = score;
                    trashRemoved = true;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('highScore', highScore);
                        highScoreEl.textContent = highScore;
                    }
                }
            });
            if (trashRemoved) {
                updateSavedTurtles();
            }
        }

        gameCanvas.addEventListener('click', handleTap);
        gameCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleTap(e, true);
        }, { passive: false });

        // Game loop
        function gameLoop() {
            if (!gameActive) return;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw status text
            ctx.fillStyle = '#fff';
            ctx.font = '24px Roboto';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Turtles: ${turtlesSaved}/${totalTurtles}`, 10, 60);
            ctx.fillText(`Time: ${Math.ceil(timeLeft)}s`, 10, 90);
            ctx.fillText(`Trash: ${totalTrash - trashItems.length}/${totalTrash}`, 10, 120);

            // Draw turtles first (background)
            turtles.forEach(turtle => turtle.draw());

            // Draw trash on top
            const shuffledTrash = [...trashItems].sort(() => Math.random() - 0.5);
            shuffledTrash.forEach(item => item.draw());

            // Draw animations
            animations = animations.filter(anim => anim.update());
            animations.forEach(anim => anim.draw());

            requestAnimationFrame(gameLoop);
        }

        // Start or reset game
        function startGame() {
            score = 0;
            turtlesSaved = 0;
            trashItems = [];
            turtles = [];
            animations = [];
            timeLeft = 30;
            spawnCluster();
            scoreEl.textContent = score;
            turtlesSavedEl.textContent = `${turtlesSaved}/${totalTurtles}`;
            timeLeftEl.textContent = Math.ceil(timeLeft);
            highScoreEl.textContent = highScore;
            gameStatus.textContent = `Score: ${score} | Turtles Saved: ${turtlesSaved}/${totalTurtles} | Time: ${Math.ceil(timeLeft)}s | High Score: ${highScore}`;
            gameActive = true;
            startBtn.style.display = 'none';
            resetBtn.style.display = 'none';

            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft -= 1;
                timeLeftEl.textContent = Math.max(0, Math.ceil(timeLeft));
                gameStatus.textContent = `Score: ${score} | Turtles Saved: ${turtlesSaved}/${totalTurtles} | Time: ${Math.ceil(timeLeft)}s | High Score: ${highScore}`;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame(false);
                }
            }, 1000); // Update every second

            gameLoop();
        }

        function resetGame() {
            clearInterval(timerInterval);
            startGame();
        }

        function endGame(isVictory) {
            gameActive = false;
            clearInterval(timerInterval);
            ctx.fillStyle = isVictory ? 'rgba(0, 128, 0, 0.7)' : 'rgba(128, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#fff';
            ctx.font = '30px Roboto';
            ctx.textAlign = 'center';
            if (isVictory) {
                gameStatus.textContent = `Victory! Score: ${score} | High Score: ${highScore} | You saved all ${turtlesSaved} turtles!`;
                ctx.fillText('Victory!', canvasWidth / 2, canvasHeight / 2 - 20);
                ctx.fillText(`Score: ${score}`, canvasWidth / 2, canvasHeight / 2 + 20);
                for (let i = 0; i < 50; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * canvasWidth, Math.random() * canvasHeight, 5, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    ctx.fill();
                }
                playSound('turtle');
            } else {
                gameStatus.textContent = `Game Over! Score: ${score} | High Score: ${highScore} | Time's up!`;
                ctx.fillText('Game Over!', canvasWidth / 2, canvasHeight / 2 - 20);
                ctx.fillText(`Score: ${score}`, canvasWidth / 2, canvasHeight / 2 + 20);
            }
            startBtn.style.display = 'block';
            resetBtn.style.display = 'block';
        }

        // Button events
        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);

        // Initialize high score display
        highScoreEl.textContent = highScore;
    </script>
</body>
</html>