<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Twitter Card Metadata -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cryptodira - Protecting Sea Turtles">
    <meta name="twitter:description" content="Join Cryptodira on Solana to support sea turtle conservation with monthly giveaways for holders!">
    <meta name="twitter:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta name="twitter:site" content="@rareseaturtles">
    <meta name="twitter:creator" content="@rareseaturtles">
    <!-- Open Graph Metadata -->
    <meta property="og:title" content="Cryptodira - Protecting Sea Turtles">
    <meta property="og:description" content="Cryptodira: A Solana token for sea turtle conservation with monthly giveaways. Connect your wallet to join!">
    <meta property="og:url" content="https://cryptodira.netlify.app/">
    <meta property="og:image" content="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg">
    <meta property="og:type" content="website">
    <!-- Additional Metadata -->
    <title>Cryptodira - Protecting Sea Turtles</title>
    <meta name="description" content="Cryptodira is a Solana token dedicated to sea turtle conservation with monthly giveaways for holders.">
    <!-- Favicon -->
    <link rel="icon" href="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" type="image/jpeg">
    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.91.1/lib/index.iife.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <!-- Google Fonts for Roboto -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #e0f7fa, #a5d6a7);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        header {
            text-align: center;
            padding: 20px 0;
            width: 100%;
        }
        header h1 {
            font-size: 48px;
            color: #2e7d32;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(46, 125, 50, 0.3);
            font-family: 'Trebuchet MS', sans-serif;
        }
        header p {
            font-size: 18px;
            color: #1b5e20;
            margin: 0;
        }
        .logo {
            width: 120px;
            height: auto;
            border-radius: 50%;
            border: 4px solid #2e7d32;
            margin: 20px auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
        }
        .logo:hover {
            transform: scale(1.05);
        }
        .content {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            margin: 20px;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 90%;
            border: 3px solid #4caf50;
            text-align: center;
        }
        .content h2, .content h3 {
            color: #2e7d32;
            margin-bottom: 15px;
        }
        .content p {
            font-size: 16px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        .button {
            padding: 12px 25px;
            font-size: 16px;
            color: #fff;
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 150px;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #1b5e20, #103d15);
        }
        #disconnect-btn {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            display: none;
        }
        #disconnect-btn:hover {
            background: linear-gradient(135deg, #b71c1c, #7f0000);
        }
        #status, #gameStatus {
            margin-top: 15px;
            font-size: 16px;
            color: #2e7d32;
            font-weight: bold;
        }
        .roadmap {
            margin: 20px 0;
            padding: 20px;
            background: rgba(232, 245, 233, 0.8);
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .roadmap ul {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        .roadmap li {
            margin: 10px 0;
            font-size: 16px;
            color: #1b5e20;
        }
        footer {
            background: #2e7d32;
            color: #fff;
            text-align: center;
            padding: 10px 0;
            width: 100%;
            margin-top: auto;
        }
        #token-info {
            font-size: 16px;
            color: #1b5e20;
        }
        #game-container {
            width: 400px;
            height: 400px;
            border: 1px solid black;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg, #f4a261, #e0c097);
            margin: 0 auto;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .bubble {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        .bubble:hover {
            transform: scale(1.1);
        }
        #score-board {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: #2e7d32;
            font-weight: bold;
        }
        #restartBtn {
            padding: 12px 25px;
            font-size: 16px;
            color: #fff;
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            min-width: 150px;
            display: none;
            margin: 15px auto;
        }
        #restartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #1b5e20, #103d15);
        }
        @media (max-width: 600px) {
            header h1 { font-size: 32px; }
            .content { padding: 15px; margin: 15px; width: 95%; }
            .button, #restartBtn { padding: 10px 20px; font-size: 14px; min-width: 120px; }
            .buttons { flex-direction: column; align-items: center; gap: 10px; }
            .logo { width: 100px; }
            #game-container { width: 100%; height: 400px; }
        }
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        #pledge-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        #pledge-modal p {
            font-size: 16px;
            color: #333;
        }
        #pledge-modal button {
            padding: 10px 20px;
            font-size: 14px;
            color: #fff;
            background: #2e7d32;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #pledge-modal button:hover {
            background: #1b5e20;
        }
    </style>
</head>
<body>
    <header>
        <img class="logo" src="https://www.arweave.net/0UBZmi9VNO_QN7lem_KJ_grHzSIMyWgHjYdK2oUds6k?ext=jpg" alt="Cryptodira Logo">
        <h1>Cryptodira</h1>
        <p>A Solana Token for Sea Turtle Conservation</p>
    </header>

    <div class="content">
        <h2>Welcome to Cryptodira ($DIRA)</h2>
        <p>Cryptodira is a Solana-based token dedicated to protecting sea turtles and supporting Earth conservation through community engagement and monthly giveaways for holders.</p>
        
        <div class="buttons">
            <button class="button" id="connect-btn" onclick="connectWallet()">Connect Wallet</button>
            <button class="button" id="disconnect-btn" onclick="disconnectWallet()">Disconnect</button>
            <button class="button" onclick="connectAndSignMessage()">Sign Pledge</button>
        </div>
        <div id="status"></div>

        <h3>Tokenomics</h3>
        <div id="token-info">
            <p>Loading token data...</p>
            <button class="button" onclick="updateTokenInfo()">Refresh</button>
        </div>

        <h3>Roadmap to 10K Liquidity & 500 Holders</h3>
        <div class="roadmap">
            <ul>
                <li><strong>April 2025:</strong> Reach 1K liquidity via Meteora pool, launch monthly giveaways for 100+ DIRA holders.</li>
                <li><strong>May 2025:</strong> Grow to 200 holders and hit 2k liquidity.</li>
                <li><strong>June 2025:</strong> Hit 3K liquidity, expand to 300 holders.</li>
                <li><strong>July 2025:</strong> Achieve 400 holders, and 4k Liquidity.</li>
                <li><strong>August 2025:</strong> Grow to 500 holders and hit 5k liquidity.</li>
                <li><strong>September 2025:</strong> Hit 6K liquidity, expand to 600 holders.</li>
                <li><strong>October 2025:</strong> Achieve 700 holders, and 7k Liquidity.</li>
            </ul>
        </div>

        <h3>Join the Community</h3>
        <div class="buttons">
            <a href="https://app.meteora.ag/pools/9H67psNKre9dMAscpsYkEPGmYFw4MjeqV5Rmott2mDmd?internal=true" class="button" target="_blank">Swap on Meteora</a>
            <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" class="button" target="_blank">Birdeye Chart</a>
            <a href="https://x.com/rareseaturtles" class="button" target="_blank">Follow on X</a>
            <a href="https://t.me/+FsJKNuEXxRRmZGRh" class="button" target="_blank">Join Telegram</a>
        </div>
    </div>

    <div class="content">
        <h2>Save the Sea Turtle Hatchling</h2>
        <p>Match 3+ obstacles (trash, birds, crabs, raccoons) to clear a path for the turtle to reach the ocean! Moves: <span id="movesLeft">20</span></p>
        <div id="game-container"></div>
        <div id="gameStatus">Clear a path for the turtle!</div>
        <button id="restartBtn" onclick="restartGame()">Restart Game</button>
    </div>

    <div id="modal-overlay"></div>
    <div id="pledge-modal"></div>

    <footer>
        <p>© 2025 Cryptodira. Supporting Sea Turtle Conservation.</p>
    </footer>

    <script>
        // DOM elements
        const connectBtn = document.getElementById("connect-btn");
        const disconnectBtn = document.getElementById("disconnect-btn");
        const statusEl = document.getElementById("status");
        const tokenInfoEl = document.getElementById("token-info");
        const gameContainer = document.getElementById('game-container');
        const gameStatus = document.getElementById('gameStatus');
        const restartBtn = document.getElementById('restartBtn');
        const movesLeftEl = document.getElementById('movesLeft');
        const scoreEl = document.getElementById('score');

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyABc3oR2hxlm_DTE9vsEHufk7BZ6TqeKP0",
            authDomain: "voting-f332e.firebaseapp.com",
            projectId: "voting-f332e",
            storageBucket: "voting-f332e.firebasestorage.app",
            messagingSenderId: "551078651014",
            appId: "1:551078651014:web:86646146a581b8dc3edd07",
            measurementId: "G-WYLGQ9B7KC"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Solana config
        const TOKEN_MINT_ADDRESS = new solanaWeb3.PublicKey("53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8");
        const RPC_ENDPOINT = "https://solana-mainnet.g.alchemy.com/v2/FhRe8GPzziOkp5qiOF5OO4erPzDYvoF_";
        const FALLBACK_RPC_ENDPOINT = "https://api.mainnet-beta.solana.com";
        const MIN_TOKEN_BALANCE = BigInt(5000000);
        let publicKey = null;
        let isTokenHolder = false;
        let walletProvider = null;
        let walletName = "Unknown";

        // Birdeye API key
        const BIRDEYE_API_KEY = "0d4d8f6a8444446cb233b2f2e933d6db";

        // Fetch token price and liquidity
        async function updateTokenInfo() {
            try {
                const response = await fetch("https://public-api.birdeye.so/defi/price?address=53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8&check_liquidity=100&include_liquidity=true", {
                    headers: {
                        "X-API-KEY": BIRDEYE_API_KEY,
                        "x-chain": "solana",
                        "accept": "application/json"
                    }
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Birdeye HTTP ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                tokenInfoEl.innerHTML = `
                    <p><strong>Price:</strong> $${data.data.value.toFixed(6)}</p>
                    <p><strong>Liquidity:</strong> $${data.data.liquidity.toFixed(2)}</p>
                    <p><strong>Mission:</strong> Fund conservation through monthly giveaways and community participation.</p>
                    <p><strong>Distribution:</strong> 20% liquidity (locked on Meteora), 15% team, 10% treasury.</p>
                    <p><strong>Track:</strong> <a href="https://birdeye.so/token/53hZ5wdfphd8wUoh6rqrv5STvB58yBRaXuZFAWwitKm8?chain=solana" target="_blank">Birdeye</a></p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            } catch (error) {
                tokenInfoEl.innerHTML = `
                    <p>Error fetching token data: ${error.message}</p>
                    <button class="button" onclick="updateTokenInfo()">Refresh</button>
                `;
            }
        }

        updateTokenInfo();

        function getConnection() {
            try {
                return new solanaWeb3.Connection(RPC_ENDPOINT, "confirmed");
            } catch (error) {
                console.warn("Primary RPC failed, switching to fallback:", error);
                return new solanaWeb3.Connection(FALLBACK_RPC_ENDPOINT, "confirmed");
            }
        }

        async function connectWallet() {
            walletProvider = null;
            publicKey = null;
            walletName = "Unknown";

            if (window.solana && window.solana.isPhantom) {
                walletProvider = window.solana;
                walletName = "Phantom";
            } else if (window.backpack && window.backpack.isBackpack) {
                walletProvider = window.backpack;
                walletName = "Backpack";
            } else if (window.jup) {
                walletProvider = window.jup;
                walletName = "Jupiter Mobile";
            } else if (window.solflare && window.solflare.isSolflare) {
                walletProvider = window.solflare;
                walletName = "Solflare";
            } else {
                statusEl.innerHTML = 'No supported wallet detected. Install <a href="https://phantom.app/" target="_blank" style="color: #2e7d32;">Phantom</a>.';
                return;
            }

            try {
                const response = await walletProvider.connect();
                publicKey = walletProvider.publicKey
                    ? walletProvider.publicKey.toString()
                    : response.publicKey.toString();

                statusEl.textContent = `Connected: ${publicKey.slice(0, 6)}...${publicKey.slice(-4)} with ${walletName}`;
                connectBtn.style.display = "none";
                disconnectBtn.style.display = "inline-block";
                await checkTokenOwnership();
            } catch (error) {
                statusEl.textContent = `Wallet connection failed: ${error.message}`;
            }
        }

        function disconnectWallet() {
            if (walletProvider && walletProvider.disconnect) {
                walletProvider.disconnect();
            }
            publicKey = null;
            walletProvider = null;
            isTokenHolder = false;
            statusEl.textContent = "Wallet disconnected";
            connectBtn.style.display = "block";
            disconnectBtn.style.display = "none";
        }

        async function checkTokenOwnership() {
            if (!publicKey) {
                statusEl.textContent = "No wallet connected.";
                return;
            }
            const connection = getConnection();
            try {
                const tokenAccounts = await connection.getTokenAccountsByOwner(
                    new solanaWeb3.PublicKey(publicKey),
                    { mint: TOKEN_MINT_ADDRESS }
                );

                let totalBalance = BigInt(0);
                for (const account of tokenAccounts.value) {
                    const balance = account.account.data.readBigUInt64LE(64);
                    totalBalance += balance;
                }

                isTokenHolder = totalBalance > MIN_TOKEN_BALANCE;
                if (isTokenHolder) {
                    statusEl.textContent = `Verified: You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA (500+ tokens)!`;
                } else {
                    statusEl.textContent = `You hold ${(Number(totalBalance) / 1e4).toFixed(4)} DIRA. Need 500+ for monthly giveaways.`;
                }
            } catch (error) {
                statusEl.textContent = "Error checking token: " + error.message;
            }
        }

        function showMessage(message, isSuccess) {
            const modal = document.getElementById('pledge-modal');
            modal.innerHTML = `<p>${message}</p><button onclick="closeModal()">Close</button>`;
            modal.style.background = isSuccess ? '#d4edda' : '#f8d7da';
            showModal();
        }

        function showModal() {
            document.getElementById('modal-overlay').style.display = 'block';
            document.getElementById('pledge-modal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('modal-overlay').style.display = 'none';
            document.getElementById('pledge-modal').style.display = 'none';
        }

        document.getElementById('modal-overlay').addEventListener('click', closeModal);

        async function connectAndSignMessage() {
            if (!window.solana || !window.solana.isPhantom) {
                showMessage('Phantom Wallet not detected. Please install it.', false);
                return;
            }

            try {
                await window.solana.connect();
                const walletAddress = window.solana.publicKey.toString();
                const message = "Welcome to Cryptodira! I promise to be nice to turtles.";
                const encodedMessage = new TextEncoder().encode(message);
                const signedMessage = await window.solana.signMessage(encodedMessage, 'utf8');
                showMessage('Pledge signed! Thank you for supporting sea turtles.', true);
            } catch (error) {
                showMessage('Error: ' + error.message, false);
            }
        }

        // Game Logic
        const ROWS = 10;
        const COLS = 10;
        const OBSTACLES = ['trash', 'bird', 'crab', 'raccoon'];
        const COLORS = {
            'sand': '#F4A460',
            'trash': '#808080',
            'bird': '#0000FF',
            'crab': '#FF0000',
            'raccoon': '#8B4513',
            'turtle': '#2e7d32',
            'ocean': '#40c4ff'
        };

        let grid = Array(ROWS).fill().map(() => Array(COLS).fill('sand'));
        let bubbles = [];
        let movesLeft = 20;
        let score = 0;
        const turtlePos = { row: 0, col: 5 };
        const oceanPos = { row: 9, col: 5 };

        // Create a bubble element
        function createBubble(row, col, type) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const xOffset = Math.random() * (40 - 20) + 10; // Random x within cell (10-30px)
            const yOffset = Math.random() * (40 - 20) + 10; // Random y within cell (10-30px)
            bubble.style.left = `${col * 40 + xOffset}px`;
            bubble.style.top = `${row * 40 + yOffset}px`;
            bubble.style.backgroundColor = COLORS[type];
            bubble.textContent = type.charAt(0).toUpperCase();
            bubble.dataset.row = row;
            bubble.dataset.col = col;
            bubble.addEventListener('click', handleBubbleClick);
            gameContainer.appendChild(bubble);
            return bubble;
        }

        // Initialize grid with bubbles
        function initializeGrid() {
            gameContainer.innerHTML = '<div id="score-board">Score: <span id="score">0</span></div>';
            bubbles = [];
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    if (Math.random() < 0.7 && !(i === turtlePos.row && j === turtlePos.col) && !(i === oceanPos.row && j === oceanPos.col)) {
                        const type = OBSTACLES[Math.floor(Math.random() * OBSTACLES.length)];
                        grid[i][j] = type;
                        bubbles.push(createBubble(i, j, type));
                    }
                }
            }
            grid[turtlePos.row][turtlePos.col] = 'turtle';
            grid[oceanPos.row][oceanPos.col] = 'ocean';
            // Add turtle and ocean as static bubbles
            bubbles.push(createBubble(turtlePos.row, turtlePos.col, 'turtle'));
            bubbles.push(createBubble(oceanPos.row, oceanPos.col, 'ocean'));
        }

        // Find a group of identical adjacent bubbles
        function getGroup(row, col) {
            if (grid[row][col] === 'sand' || grid[row][col] === 'turtle' || grid[row][col] === 'ocean') return [];
            let type = grid[row][col];
            let visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            let queue = [[row, col]];
            let group = [];
            
            while (queue.length > 0) {
                let [r, c] = queue.shift();
                if (visited[r][c]) continue;
                visited[r][c] = true;
                if (grid[r][c] === type && grid[r][c] !== 'turtle' && grid[r][c] !== 'ocean') {
                    group.push([r, c]);
                    if (r > 0 && !visited[r-1][c]) queue.push([r-1, c]);
                    if (r < ROWS-1 && !visited[r+1][c]) queue.push([r+1, c]);
                    if (c > 0 && !visited[r][c-1]) queue.push([r, c-1]);
                    if (c < COLS-1 && !visited[r][c+1]) queue.push([r, c+1]);
                }
            }
            return group;
        }

        // Remove a group with animation
        function removeGroup(group) {
            const totalPoints = group.length * 10;
            score += totalPoints;
            scoreEl.textContent = score;
            let toRemove = [];
            for (let [r, c] of group) {
                grid[r][c] = 'sand';
                toRemove.push(bubbles.find(b => b.dataset.row == r && b.dataset.col == c));
            }
            toRemove.forEach(bubble => {
                bubble.style.opacity = '0';
                bubble.style.transform = 'scale(0)';
                setTimeout(() => bubble.remove(), 200); // Remove after animation
            });
            if (hasPath(turtlePos, oceanPos)) {
                gameWon = true;
                gameStatus.textContent = `You Win! Score: ${score} | The turtle reached the ocean!`;
                restartBtn.style.display = 'block';
            }
        }

        // Check if there’s a path from start to end through sand
        function hasPath(start, end) {
            let visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            let queue = [start];
            visited[start.row][start.col] = true;
            
            while (queue.length > 0) {
                let current = queue.shift();
                if (current.row === end.row && current.col === end.col) return true;
                let neighbors = [
                    { row: current.row-1, col: current.col },
                    { row: current.row+1, col: current.col },
                    { row: current.row, col: current.col-1 },
                    { row: current.row, col: current.col+1 }
                ];
                for (let neighbor of neighbors) {
                    if (neighbor.row >= 0 && neighbor.row < ROWS && 
                        neighbor.col >= 0 && neighbor.col < COLS && 
                        (grid[neighbor.row][neighbor.col] === 'sand' || grid[neighbor.row][neighbor.col] === 'ocean') && 
                        !visited[neighbor.row][neighbor.col]) {
                        queue.push(neighbor);
                        visited[neighbor.row][neighbor.col] = true;
                    }
                }
            }
            return false;
        }

        // Handle bubble click
        function handleBubbleClick(e) {
            if (gameOver || gameWon) return;
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const group = getGroup(row, col);
            if (group.length >= 3) {
                removeGroup(group);
                movesLeft--;
                movesLeftEl.textContent = movesLeft;
                if (movesLeft <= 0) {
                    gameOver = true;
                    gameStatus.textContent = `Game Over! Score: ${score} | No moves left!`;
                    restartBtn.style.display = 'block';
                } else {
                    gameStatus.textContent = `Score: ${score} | Moves left: ${movesLeft} | Clear a path for the turtle!`;
                }
            }
        }

        // Game state
        let gameOver = false;
        let gameWon = false;

        // Restart the game
        function restartGame() {
            grid = Array(ROWS).fill().map(() => Array(COLS).fill('sand'));
            movesLeft = 20;
            score = 0;
            gameOver = false;
            gameWon = false;
            movesLeftEl.textContent = movesLeft;
            scoreEl.textContent = score;
            gameStatus.textContent = `Score: ${score} | Moves left: ${movesLeft} | Clear a path for the turtle!`;
            restartBtn.style.display = 'none';
            initializeGrid();
        }

        // Start the game
        initializeGrid();
    </script>
</body>
</html>